# concept

## 数据结构
1. 数据对象在计算机中的组织方式
  1. 逻辑结构
  2. 物理存储结构
2. 数据对象相关联的操作集
3. 处理数据对象的高效算法

## 抽象数据类型(Abstract Data Type, ADT)
1. 数据类型
  1. 数据对象集
  2. 与数据集合相关联的操作集
2. 抽象
  不依赖具体实现
  只描述数据对象集和相关操作集“是什么”，不涉及“如何做到”
  ElementType

## 算法
1. 有限指令集
2. 接受一些输入，产生输出
3. 在有限步骤之后终止
4. (伪码描述)
```
void SelectionSort(int List[], int N)
{
  for (int i = 0; i < N; i++)
  {
    MinPosition = ScanForMin(List, i, N-1);
    Swap(List[i], List[MinPosition]);
  }
}
```

## 算法复杂度
1. 空间复杂度 S(n)
  根据算法写成的程序在执行时占用存储单元的长度
2. 时间复杂度 T(n)
  根据算法写成的程序在执行时耗费时间的长度
  1. 最坏情况复杂度 T_worst(n)
  2. 平均复杂度 T_avg(n)

## 渐进表示法
1. 概念
  > 存在常数 C > 0, n_0 > 0, 使得当 n >= n_0 时，有：
  1. O: `T(n) = O(f(n)) => T(n) <= C(f(n))`，上界
  2. Ω: `T(n) = Ω(f(n)) => T(n) >= C(f(n))`，下界
  3. Θ: `T(n) = Θ(f(n)) => T(n) = O(f(n)) && T(n) = Ω(f(n))`
2. 对 S(n), T(n) 都适用
3. 渐进分析的小tips
  1. 串联的复杂度：
    `T_1(n) + T_2(n) = max(O(f_1(n)), O(f_2(n)))`
  2. 嵌套的复杂度
    `T_1(n) * T_2(n) = O(f_1(n)) * O(f_2(n))`
  3. T(n) 是关于 n 的 k 阶多项式
    `T(n) = Θ(pow(n, k))`
  4. for 循环的复杂度 == 循环次数 * 循环体代码的复杂度
  5. if-else 结构的复杂度
    ```
    if (p1) // p1 O(f1)
      p2 // p2 O(f2)
    else p3 // p3 O(f3)

    总复杂度 = max(O(f1), O(f2), O(f3))
    ```